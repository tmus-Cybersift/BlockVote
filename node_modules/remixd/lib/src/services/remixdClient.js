"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemixdClient = void 0;
var plugin_1 = require("@remixproject/plugin");
var utils = require("../utils");
var chokidar = require("chokidar");
var fs = require("fs-extra");
var isbinaryfile = require('isbinaryfile');
var RemixdClient = /** @class */ (function (_super) {
    __extends(RemixdClient, _super);
    function RemixdClient() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.trackDownStreamUpdate = {};
        return _this;
    }
    RemixdClient.prototype.setWebSocket = function (websocket) {
        this.websocket = websocket;
    };
    RemixdClient.prototype.sharedFolder = function (currentSharedFolder, readOnly) {
        this.currentSharedFolder = currentSharedFolder;
        this.readOnly = readOnly;
    };
    RemixdClient.prototype.list = function () {
        try {
            return utils.walkSync(this.currentSharedFolder, {}, this.currentSharedFolder);
        }
        catch (e) {
            throw new Error(e);
        }
    };
    RemixdClient.prototype.resolveDirectory = function (args) {
        try {
            var path = utils.absolutePath(args.path, this.currentSharedFolder);
            var result = utils.resolveDirectory(path, this.currentSharedFolder);
            return result;
        }
        catch (e) {
            throw new Error(e);
        }
    };
    RemixdClient.prototype.folderIsReadOnly = function () {
        return this.readOnly;
    };
    RemixdClient.prototype.get = function (args) {
        var _this = this;
        try {
            return new Promise(function (resolve, reject) {
                var path = utils.absolutePath(args.path, _this.currentSharedFolder);
                if (!fs.existsSync(path)) {
                    return reject('File not found okok ' + path);
                }
                if (!isRealPath(path))
                    return;
                isbinaryfile(path, function (error, isBinary) {
                    if (error)
                        console.log(error);
                    if (isBinary) {
                        resolve({ content: '<binary content not displayed>', readonly: true });
                    }
                    else {
                        fs.readFile(path, 'utf8', function (error, data) {
                            if (error)
                                console.log(error);
                            resolve({ content: data, readonly: false });
                        });
                    }
                });
            });
        }
        catch (error) {
            throw new Error(error);
        }
    };
    RemixdClient.prototype.exists = function (args) {
        try {
            var path = utils.absolutePath(args.path, this.currentSharedFolder);
            return fs.existsSync(path);
        }
        catch (error) {
            throw new Error(error);
        }
    };
    RemixdClient.prototype.set = function (args) {
        var _this = this;
        try {
            return new Promise(function (resolve, reject) {
                if (_this.readOnly)
                    reject('Cannot write file: read-only mode selected');
                var isFolder = args.path.endsWith('/');
                var path = utils.absolutePath(args.path, _this.currentSharedFolder);
                var exists = fs.existsSync(path);
                if (exists && !isRealPath(path))
                    reject();
                if (args.content === 'undefined') { // no !!!!!
                    console.log('trying to write "undefined" ! stopping.');
                    reject('trying to write "undefined" ! stopping.');
                }
                _this.trackDownStreamUpdate[path] = path;
                if (isFolder) {
                    fs.mkdirp(path).then(function () {
                        var splitPath = args.path.split('/');
                        splitPath = splitPath.filter(function (dir) { return dir; });
                        var dir = '/' + splitPath.join('/');
                        _this.emit('folderAdded', dir);
                        resolve();
                    }).catch(function (e) { return reject(e); });
                }
                else {
                    fs.ensureFile(path).then(function () {
                        fs.writeFile(path, args.content, 'utf8', function (error) {
                            if (error) {
                                console.log(error);
                                reject(error);
                            }
                            resolve();
                        });
                    }).catch(function (e) { return reject(e); });
                    if (!exists) {
                        _this.emit('fileAdded', args.path);
                    }
                    else {
                        _this.emit('fileChanged', args.path);
                    }
                }
            });
        }
        catch (error) {
            throw new Error(error);
        }
    };
    RemixdClient.prototype.rename = function (args) {
        var _this = this;
        try {
            return new Promise(function (resolve, reject) {
                if (_this.readOnly)
                    reject('Cannot rename file: read-only mode selected');
                var oldpath = utils.absolutePath(args.oldPath, _this.currentSharedFolder);
                if (!fs.existsSync(oldpath)) {
                    reject('File not found ' + oldpath);
                }
                var newpath = utils.absolutePath(args.newPath, _this.currentSharedFolder);
                if (!isRealPath(oldpath))
                    return;
                fs.move(oldpath, newpath, function (error) {
                    if (error) {
                        console.log(error);
                        reject(error.message);
                    }
                    _this.emit('fileRenamed', args.oldPath, args.newPath);
                    resolve(true);
                });
            });
        }
        catch (error) {
            throw new Error(error);
        }
    };
    RemixdClient.prototype.remove = function (args) {
        var _this = this;
        try {
            return new Promise(function (resolve, reject) {
                if (_this.readOnly)
                    reject('Cannot remove file: read-only mode selected');
                var path = utils.absolutePath(args.path, _this.currentSharedFolder);
                if (!fs.existsSync(path))
                    reject('File not found ' + path);
                if (!isRealPath(path))
                    return;
                return fs.remove(path, function (error) {
                    if (error) {
                        console.log(error);
                        reject('Failed to remove file/directory: ' + error);
                    }
                    _this.emit('fileRemoved', args.path);
                    resolve(true);
                });
            });
        }
        catch (error) {
            throw new Error(error);
        }
    };
    RemixdClient.prototype.isDirectory = function (args) {
        try {
            var path = utils.absolutePath(args.path, this.currentSharedFolder);
            return fs.statSync(path).isDirectory();
        }
        catch (error) {
            throw new Error(error);
        }
    };
    RemixdClient.prototype.isFile = function (args) {
        try {
            var path = utils.absolutePath(args.path, this.currentSharedFolder);
            return fs.statSync(path).isFile();
        }
        catch (error) {
            throw new Error(error);
        }
    };
    RemixdClient.prototype.setupNotifications = function (path) {
        var _this = this;
        var absPath = utils.absolutePath('./', path);
        if (!isRealPath(absPath))
            return;
        var watcher = chokidar.watch(path, { depth: 0, ignorePermissionErrors: true });
        console.log('setup notifications for ' + path);
        /* we can't listen on created file / folder
        watcher.on('add', (f, stat) => {
          isbinaryfile(f, (error, isBinary) => {
            if (error) console.log(error)
            console.log('add', f)
            this.emit('created', { path: utils.relativePath(f, this.currentSharedFolder), isReadOnly: isBinary, isFolder: false })
          })
        })
        watcher.on('addDir', (f, stat) => {
          this.emit('created', { path: utils.relativePath(f, this.currentSharedFolder), isReadOnly: false, isFolder: true })
        })
        */
        watcher.on('change', function (f) {
            if (_this.trackDownStreamUpdate[f]) {
                delete _this.trackDownStreamUpdate[f];
                return;
            }
            _this.emit('changed', utils.relativePath(f, _this.currentSharedFolder));
        });
        watcher.on('unlink', function (f) {
            _this.emit('removed', utils.relativePath(f, _this.currentSharedFolder), false);
        });
        watcher.on('unlinkDir', function (f) {
            _this.emit('removed', utils.relativePath(f, _this.currentSharedFolder), true);
        });
    };
    return RemixdClient;
}(plugin_1.PluginClient));
exports.RemixdClient = RemixdClient;
function isRealPath(path) {
    var realPath = fs.realpathSync(path);
    var isRealPath = path === realPath;
    var mes = '[WARN] Symbolic link modification not allowed : ' + path + ' | ' + realPath;
    if (!isRealPath) {
        console.log('\x1b[33m%s\x1b[0m', mes);
        // throw new Error(mes)
    }
    return isRealPath;
}
